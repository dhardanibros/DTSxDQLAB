---
title: "Customer Segmentation"
author: "Shella Pandiangan"
date: "2022-08-10"
output: html_document
---



Apa yang akan Anda pelajari sepanjang course ini?

    Apa dan kenapa Customer Segmentation dalam penggunaan di bisnis?
    Aplikasi Customer Segmentation secara teknis dengan Algoritma K-Means di R
    Bagaimana mempersiapkan data profil pelanggan di R agar dapat digunakan oleh algoritma K-Means
    Mempaketkan algoritma sebagai model dan mengoperasionalkannya sehingga dapat digunakan sehari-hari oleh bisnis

Oleh sebab itu, sebelum kita mulai, mari menonton link berikut ini :
https://academy.dqlab.id/main/livecode/7/13/40?pr=0

Quiz 

Apa tujuan utama Customer Segmentation bagi bisnis?

JAWABAN

A. Dapat membuat pesan pemasaran yang lebih mengena ke tiap pelanggan
B. Bisa meminjam uang dari bank dengan lebih gampang
C. Bisa memilih produk yang dijual, sesuai kebutuhan pelanggan
D. Bisa lebih mengenal customer / pelanggan
E. Biaya pemasaran bisa menjadi lebih rendah

Jawab :
A,D,E


Kenapa Perlu Bantuan Algoritma untuk Customer Segmentation?
Apa alasan paling kuat kenapa kita akhirnya harus menggunakan algoritma komputer untuk membantu proses customer segmentation

JAWABAN
A. Agar kita dapat membagi-bagi segmen customer dengan gampang
B. Dapat membantu kita menentukan jumlah clustering yang optimal
C. Bisa memilih produk yang dijual, sesuai kebutuhan pelanggan
D. Dapat memberikan hasil jauh lebih cepat
E. Karena bisa memberikan best practice

Jawab :
A,B,D,E

Kesimpulan

1. Customer segmentation adalah proses penting yang diperlukan di bisnis untuk mengenal customer dengan lebih baik. Dengan demikian proses bisnis di marketing (pemasaran) dan CRM (customer relationship management) bisa dilakukan lebih tajam. Contoh: pesan marketing bisa lebih personal untuk setiap segment dengan biaya lebih optimal.
2. Dengan proses yang lebih tajam, performa bisnis berpotensi tinggi menjadi lebih baik juga.
3. Untuk menemukan segmentasi yang baik, perlu proses analisa data dari profile customer yang cukup banyak dan rutin. Ini bisa dibantu dengan algoritma komputer.


A. Persiapan data adalah langkah pertama yang kita lakukan sebelum menggunakan algoritma apapun untuk melakukan analisa data.
Ini dikarenakan tiap implementasi algoritma menuntut struktur dan tipe data yang berbeda.
Dan untuk kasus algoritma K-Means yang akan kita gunakan untuk otomatisasi clustering, maka struktur datanya adalah data.frame atau matrix yang di dalamnya berisi angka semua. Tidak ada yang boleh bertipe karakter.

Namun pada kasus riil, hal ini tentulah tidak mungkin. Contoh, isi data profesi seperti "Professional", "Ibu Rumah Tangga" adalah teks. Dan ini perlu dikonversi dulu ke numerik, namun jika diperlukan tetap bisa kembali mengambil data teks.

Nah, untuk lebih jelasnya. Kita akan lakukan langkah-langkah praktek yang akan kita lakukan berikut ini adalah untuk mempersiapkan data sebelum dapat digunakan algoritma clustering:

1. Mengenal Contoh File Dataset Pelanggan (source berbeda-beda, bisa dari kaggel, dqlab dalam bentuk excel/csv)
2. Membaca File dengan read.csv (Jika data dalam bentuk csv)
3. Vector untuk Menyimpan Nama Field
4. Konversi Data dengan data.matrix
5. Menggabungkan Hasil Konversi
6. Menormalisasikan Nilai Belanja
7. Membuat Data Master

**Dataset Customer Segments**

Dataset yang kita gunakan adalah *data customer dengan field “Customer ID”, “Nama Pelanggan”,”Jenis Kelamin”,”Umur”, “Profesi”, “Tipe Residen” dan “Nilai Belanja Setahun”* 

Dataset ini bisa dilihat di https://storage.googleapis.com/dqlab-dataset/customer_segments.txt


Data tersebut memiliki tujuh kolom dengan penjelasan sebagai berikut:

1. *Customer ID*: Kode pelanggan dengan format campuran teks CUST- diikuti angka
2. *Nama Pelanggan*: Nama dari pelanggan dengan format teks tentunya
3. *Jenis Kelamin*: Jenis kelamin dari pelanggan, hanya terdapat dua isi data kategori yaitu Pria dan Wanita
4. *Umur*: Umur dari pelanggan dalam format angka
5. *Profesi*: Profesi dari pelanggan, juga bertipe teks kategori yang terdiri dari Wiraswasta, Pelajar, Professional, Ibu Rumah Tangga, dan Mahasiswa.
6. *Tipe Residen*: Tipe tempat tinggal dari pelanggan kita, untuk dataset ini hanya ada dua kategori: Cluster dan Sector.
7. *NilaiBelanjaSetahun*: Merupakan jumlah uang yang dibelanjakan dalam setahun.

Terlihat kalau ada kolom yang berisi *angka saja, yaitu Umur dan NilaiBelanjaSetahun*. 

Sisanya diisi *data kategori untuku kolom "Jenis Kelamin", "Profesi" dan "Tipe Residen"*. Sedangkan *"Customer ID" dan "Nama Pelanggan" kita anggap memiliki nilai yang unik* untuk tiap baris data dan mewakili tiap individu.

Karena *kolom "Customer ID" dan "Nama Pelanggan" karena unik maka tidak akan dijadikan variable penentu segmentasi yang kita lakukan*, namun sisa kolom lainnya akan digunakan.

Nah dengan contoh dataset inilah, *kita akan mencoba mencari jumlah segmentasi yang paling optimal* – dimana antar tiap data pelanggan dalam segmen memiliki kemiripan tinggi.

Langkah-langkah :
1. Membaca data dengan fungsi read.csv

```{r}
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan #memanggil name variable yang sudah kita buat

pelanggan[c("Jenis.Kelamin","Umur","Profesi","Tipe.Residen")] #memanggil variable dengan kolom tertentu sesuai dengan kebutuhan.

```

Keterangan code :


a. pelanggan: nama variable yang digunakan untuk menampung data dari contoh dataset
b. csv: function yang digunakan untuk membaca contoh dataset yang berupa file
c. https://storage.googleapis.com/dqlab-dataset/customer_segments.txt: lokasi dataset yang terdapat di web DQLab. Jika lokasi file dan aplikasi R terdapat di komputer lokal Anda, maka gantilah dengan lokasi file di lokal. Misalkan c:\data\customer_segments.txt

------Jika terjadi error berikut, maka periksa kembali penulisan code – huruf besar, huruf kecil dan juga penulisan lokasi file – dengan teliti-----

Error in file(file, "rt") : cannot open the connection

2. Vector Untuk Menyimpan Nama Field

--Perhatikan jika nama-nama field yang telah kita gunakan pada praktek sebelumnya, sebenarnya adalah sebuah vector--


c("Jenis.Kelamin", "Umur", "Profesi", "Tipe.Residen")

Dan ini bisa dimasukkan ke dalam variable, dengan tujuan dapat digunakan berulang kali dalam script R.

```{r}
#Membaca data csv dan dimasukkan ke variable pelanggan
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt",sep="\t")


#Buat variable field_yang_digunakan dengan isi berupa vector "Jenis.Kelamin", "Umur" dan "Profesi"



field_yang_digunakan <- c("Jenis.Kelamin","Umur","Profesi")



#Tampilan data pelanggan dengan nama kolom sesuai isi vector field_yang_digunakan
pelanggan[field_yang_digunakan]


```

3. Konversi Data dengan data.matrix

Seperti telah dijelaskan sebelumnya, isi data dari tiga kolom pelanggan yaitu "Jenis.Kelamin", "Profesi" dan "Tipe.Residen" merupakan data kategori yang berupa teks.

Untuk fungsi k-means, ketiga kolom ini tidak bisa digunakan kecuali isi dikonversi menjadi numerik. Salah satu caranya adalah dengan menggunakan fungsi data.matrix.

*data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi")])*

Perintah ini akan mengkonversi data pelanggan pada kolom "Jenis.Kelamin" dan "Profesi" yang diwakili oleh pelanggan[c("Jenis.Kelamin", "Profesi")] menjadi numerik.


```{r}
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt",sep="\t")


#Konversi data menjadi numerik

pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])

pelanggan
pelanggan_matrix
```


4. Menggabungkan Hasil Konversi


Setelah Anda bisa melakukan konversi ke angka, kita perlu mengetahui bagaimana menggabungkan kembali data tersebut ke variable asal kita.

Ini berguna terutam apada praktek lanjutan di akhir course, yaitu ketika kita akan mengenali data pelanggan baru masuk ke segment mana.

Untuk menggabungkan data hasil konversi data.matrix ke pelanggan, kita gunakan funtion data.frame.

```{r}
#Membaca dataset
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt",sep="\t")

#Covert katgorical to numerical

pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])


#Penggabungan data numerical yg sudah di convert dan dataset sebelumnya


pelanggan <- data.frame(pelanggan, pelanggan_matrix)


#Tampilkan kembali data hasil penggabungan
pelanggan
#Jika header column sama, dia akan mengikuti dengan menambahkan .duplikat ke - di headernya.

```


5. Menormalisasikan Nilai Belanja

Mari kita lihat nilai belanja setahu, apakah sudah memiliki persebaran data yang normal...?

```{r}
pelanggan
```
Apakah di dalam Clustering bisa menggunakan data seperti tersebut??

Jika tidak, treatment apa yang harus kita lakukan??

Jawab----

"NilaiBelanjaSetahun" isi datanya bernilai jutaan. Ketika kolom ini digunakan untuk clustering, perhitungan sum of squared errors (pada bab kmeans) akan menjadi sangat besar.

Kita akan menormalisasikan nilainya agar perhitungan lebih sederhana dan mudah dicerna, namun tidak mengurangi akurasi. Ini terutama akan sangat bermanfaat jika jumlah data sangat banyak, misalkan memiliki 200 ribu data.

Normalisasi bisa dilakukan dengan banyak cara. Untuk kasus kita, cukup dengan pembagian sehingga nilai jutaan menjadi puluhan.

Bagaimana caranya ?



```{r}

#Membaca data set dari csv
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")

#convert categorical to numerical

pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])

#join data numerical and categorical
pelanggan <- data.frame(pelanggan, pelanggan_matrix)


#Normalisasi Nilai
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun / 1000000
pelanggan

```


6. Membuat Master Data

Setelah penggabungan data, kita jadi mengetahui sebenarnya teks kategori dikonversi menjadi angka numerik berapa.

Sebagai contoh, jika kita menampilkan data kolom "Profesi" dan "Profesi.1" dengan perintah berikut.

```{r}
pelanggan[c("Profesi","Profesi.1")] 
```

Dari hasil convert ini dpaat kitra lihat bahwa setiap data profesi wiraswasta akan di konversi menjadi 5, proffesional 4, pelajar 3, Mahasiswa 2, Ibu rumah tangga 1.

Daftar data kategori dan hasil konversinya sangat penting untuk dijadikan referensi sehingga nanti ketika ada data baru, kita bisa "petakan" menjadi data numerik yang siap digunakan untuk algoritma clustering.

Nah, masalahnya data di atas terlalu panjang, padahal sebenarnya kita cuma perlu 5 baris data bukan? Di R, kita bisa meringkasnya dengan function unique.

```{r}
unique(pelanggan[c("Profesi","Profesi.1")])
```

```{r}
#Membaca data
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt",sep="\t")

#Convert Data
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])

#Penggabungan Data
pelanggan <- data.frame(pelanggan, pelanggan_matrix)

#Normalisasi Data
pelanggan$NilaiBelanjaSetahun = pelanggan$NilaiBelanjaSetahun/1000000


#Mengisi data master
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Residen <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])


#Pemanggilan Field Data Master
Profesi
Jenis.Kelamin
Tipe.Residen

```
**Kesimpulan**

Selamat, Anda sudah menjalankan praktek-praktek yang menjadi dasar dari semua hal sebelum penggunaan analisa data, yaitu tahap persiapan data atau data preparation.

Untuk algoritma clustering k-means yang akan kita gunakan di R, maka tahap data preparationnya adalah menyiapkan data yang di dalamnya harus berisi numerik.

Namun *pada banyak kasus riil, data tidak sepenuhnya berisi numerik* seperti telah kita lihat sendiri dan praktekkan dengan contoh dataset yang digunakan pada bab ini dengan langkah-langkah berikut:

1. Mengenal Contoh File Dataset Pelanggan, dimana kita mengerti dulu bagaimana bentuk dan isi dari contoh yang digunakan.
2. Membaca File dengan read.csv, dimana kita membaca suatu file teks dengan pemisah berupa tab menggunakan fungsi read.csv.
3. Vector untuk Menyimpan Nama Field, dimana nama-nama field bisa disimpan dalam bentuk vector sehingga bisa digunakan berulang ketika kita buturh referensi nama-nama field yang sama.
4. Konversi Data dengan data.matrix, dimana kita bisa melakukan konversi data dari kategori teks menjadi numerik.
5. Menggabungkan Hasil Konversi, dimana hasil konversi ini perlu kita gabungkan kembali ke variable asal agar kita tidak kehilangan referensinya.
6. Menormalisasikan Nilai Belanja, dimana kita merubah skala data nilai belanja dari jutaan menjadi puluhan dengan tujuan penyederhanaan perhitungan namun tidak mengurangi akurasi.
7. Membuat Data Master, dimana kita meringkas data kategori dan numerik ke dalam variable-variable yang kita sebut sebagai data master.

Dengan demikian, kita sudah siap melangkah ke bab berikutnya: *Clustering dan Algoritma K-Means.*

--------------------------------------------------

A. MENGENAL LEBIH DEKAT CLUSTERING DAN K-MEANS

A.1. Apa itu Clustering?

A.2. Apa Itu K-Means?

*Clustering* adalah proses pembagian objek-objek ke dalam beberapa kelompok (cluster) berdasarkan tingkat kemiripan antara satu objek dengan yang lain.

Beberapa contoh clustering:

1. Pengelompokan manusia berdasarkan umur: bayi, balita, anak, remaja, dewasa, tua.
2. Pengelompokan customer berdasarkan daya belinya: regular dan premium.
3. Pengelompokan makanan berdasarkan kandungan gizinya: biji-bijian, sayuran, buah-buahan, minyak, protein, dan lain-lain.

Banyak algoritma telah dikembangkan untuk melakukan clustering secara otomatis, salah satu yang *sangat populer adalah K-Means* yang akan menjadi fokus utama course kita.

*K-means* adalah algoritma yang membagi data menjadi sejumlah partisi dengan cara sederhana: mencari kedekatan dari tiap titik pada suatu cluster dengan sejumlah nilai rata-rata atau mean.

Ada dua konsep kunci yang juga menjadi nama asal k-means:

1. Jumlah partisi yang diinginkan, diwakili oleh huruf k
2. Mencari "jarak" kedekatan tiap titik ke sejumlah nilai rata-rata cluster yang diamati, diwakili oleh means

Algoritma k-means sudah ada di paket dasar R dalam bentuk function bernama kmeans. Sepanjang bab ini, kita akan menggunakan function ini dan menganalisa output yang dihasilkan.

Cek : https://www.youtube.com/watch?v=6QV4vPpDxKQ&feature=emb_imp_woyt


FUNGSI K MEANS :


Praktek kali ini kita akan melakukan segmentasi langsung pada data pelanggan – yang telah kita lakukan persiapan datanya pada bab sebelumnya – dengan menggunakan function kmeans.

Function kmeans memerlukan minimal 2 parameter, yaitu:

1. x: data yang digunakan, dimana semua isi datanya harus berupa numerik.
2. centers: jumlah cluster yang diinginkan.

Terbaik disini artinya jarak antara tiap titik ke mean dari clusternya sendiri *lebih kecil* dibandingkan ke mean dari cluster lain.

Catatan: Mean atau nilai rata-rata disini sering disebut juga dengan centroid pada berbagai literatur data science.

Dan fungsi kmeans ini biasanya disertai dengan pemanggilan function *seet.seed.* Ini berguna agar kita *“menyeragamkan”* daftar nilai acak yang sama dari kmeans sehingga kita mendapatkan *output yang sama.*

Berikut adalah contoh penggunaan fungsi kombinasi set.seed dan kmean.

```{r}

set.seed(1)
kmeans(x=pelanggan[c("Umur","Profesi.1")], centers=3)

```

Ini artinya kita membagi data pelanggan berdasarkan “Umur” dan “Profesi” menjadi 3 segmen.

Kadang kala berdasarkan pengalaman DQLab, parameter data dan jumlah segmen saja tidak cukup. Perlu digunakan parameter ketiga yaitu *nstart*, merupakan jumlah kombinasi acak yang dihasilkan secara internal oleh R. Dan dalam jumlah yang kita berikan, algoritma akan memilih mana yang terbaik dari kombinasi-kombinasi tersebut.

Kata *terbaik* berarti jarak antara tiap titik ke mean dari clusternya sendiri lebih kecil dibandingkan ke mean dari cluster lain.

Perlu untuk diingat bahwa mean atau nilai rata-rata di sini sering disebut juga dengan *centroid* pada berbagai literatur data science.

 

Berikut adalah modifikasi pemanggilan fungsi dengan parameter tambahan nstart sebesar 25.


```{r}
kmeans(x=pelanggan[c("Umur","Profesi.1")], centers=3, nstart=25)
```

K-means clustering with 3 clusters of sizes 15, 16, 19 = Ukuran / Jumlah titik pada ukuran cluster.

Cluster Means : Nilai rata-rata (centroid) dari tiap cluster

Clustering Vektor : Pembagian cluster dari tiap elemen data berdasarkan posisinya

[1] 269.5000 237.0667 715.5789 : Jumlah jarak kuadrat dari tiap titik ke centroidnya

Available components : Komponen informasi lain yang terkandung di dalam objek kmeans ini

```{r}
#Bagian Data Preparation yaitu pembacaan data

pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")

#Covert data
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])

#penggabungan data
pelanggan <- data.frame(pelanggan, pelanggan_matrix)

#membuat master data
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])

#normalisasi data
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")


#Bagian K-Means
set.seed(1)
#fungsi kmeans untuk membentuk 5 cluster dengan 25 skenario random dan simpan ke dalam variable segmentasi

segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)

#tampilkan hasil k-means
segmentasi


```

Analisa Hasil Clustering Vector

Clustering vector ini adalah rangkaian vector yang berisi angka cluster. Dari hasil kita, vector berisi angka 1 sampai dengan 5, maksimum sesuai dengan jumlah cluster yang kita inginkan.

Vektor ini di mualai dari angka 3 yang artinya data pertama di lakukan cluster menjadi cluaster ke 3, dan seterusnya.

```{r}
#Bagian Data Preparation

pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")

pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])

pelanggan <- data.frame(pelanggan, pelanggan_matrix)

Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])

Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])

Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])

pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000

field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")

#Bagian K-Means

set.seed(1)

segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)

#Penggabungan hasil cluster

segmentasi$cluster

pelanggan$cluster <- segmentasi$cluster

str(pelanggan)


```
Analisa Hasil Cluster

Setiap Cluster memiliki jumlah data masing-masing yang artinya, setiap cluster memiliki jumlah yang berbeda-beda. Sekarang mari kita coba :

```{r}
which(pelanggan$cluster == 1)
which(pelanggan$cluster == 2)
which(pelanggan$cluster == 3)
which(pelanggan$cluster == 4)
which(pelanggan$cluster == 5)

```
Dari data diatas kita dapat bahwa cluster pertama memiliki 12 data, cluster kedua memiliki 10 data, cluster ke tiga memiliki 5 data, cluster ke empat memiliki 14 data, cluster ke lima memiliki 9 data.

```{r}
length(which(pelanggan$cluster == 1))
```


```{r}
#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
#Bagian K-Means
set.seed(1)
segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)
pelanggan$cluster <- segmentasi$cluster
#Analisa hasil
#Filter cluster ke-1
which(pelanggan$cluster == 1)
length(which(pelanggan$cluster == 2))
```
MELIHAT DATA PADA CLUSTER KE N

```{r}
#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")

#Convert Data
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])

#Join Data
pelanggan <- data.frame(pelanggan, pelanggan_matrix)

#Membuat Master Data
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])

#Normalisasi Data
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")

#Bagian K-Means
set.seed(1)
segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)
pelanggan$cluster <- segmentasi$cluster

#Analisa hasil
#Melihat data cluster ke 3-5
pelanggan[which(pelanggan$cluster == 3),] 


pelanggan[which(pelanggan$cluster == 4),] 


pelanggan[which(pelanggan$cluster == 5),] 
```

ANALISA HASIL CLUSTER MEANS

```{r}
#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Residen <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
#Bagian K-Means
set.seed(1)
segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)
pelanggan$cluster <- segmentasi$cluster
#Analisa hasil
#Melihat cluster means dari objek 
segmentasi$centers
Profesi
Tipe.Residen
```

Apa artinya hasil diatas?

Apa artinya hasil tersebut?

1. Kolom pertama yang berisi angka 1 sampai dengan 5 adalah mewakili nomor cluster.
2. Kolom Kelamin.1 menunjukkan nilai rata-rata dari data jenis kelamin yang telah dikonversi menjadi numerik, dengan angka 1 mewakili Pria dan angka 2 mewakili wanita

Pada Cluster pertama terlihat bahwa jenis kelamin di angka 1.75 yang artinya data tersebut campuran jenis kelamin pria dan wanita namun cenderung ke wanita (2), pada cluster kedua data tersebut juga terdiri dari campuran jenis kelamin pria dan wanita, namun cendrung ke pria (1), dst

Kedua interpretasi angka ini sesuai dengan hasil praktek “Melihat Data pada Cluster-N”.

*Kolom Umur* adalah representasi dari dataset awal tanpa mengalami konversi. Terlihat untuk cluster ke-1 umur rata-rata adalah 31 tahun, umur 61 tahun untuk cluster ke-2, dan seterusnya.

Kolom 1 menunjukkan nilai rata-rata data Profesi untuk tiap cluster yang telah dikonversi menjadi numerik.
Wiraswasta	:5		
Pelajar	:3		
Professional	:4		
Ibu Rumah Tangga	:1		
Mahasiswa	:2	

Terlihat untuk seluruh cluster, profesi cenderung ke Professional terutama untuk cluster ke-5.

Kolom Tipe.Residen.1 menunjukkan representasi data Tipe.Residen yang telah dikonversi menjadi numerik dengan angka 1 mewakili Cluster dan 2 mewakili Sector.

Terlihat untuk seluruh cluster, terlihat data cukup tersebar antara Sector dan Cluster terutama untuk cluster ke-5 dimana nilai kolom ini di angka 1.555.

Terakhir, kolom NilaiBelanjaSetahun cukup signifikan pembagiannya untuk tiap cluster. Dimana cluster ke-3 dan ke-5 memiliki nilai belanja lebih tinggi dibandingkan ketiga cluster lainnya.

Ini mungkin target customer yang bisa lebih disasar melalui marketing campaign, karena cluster ke-3
saat ini hanya berisi 5 data. Cukup kecil proporsinya, dan ingin ditingkatkan.

```{r}
which(pelanggan$cluster == 3)
length(which(pelanggan$cluster == 3))
```
Analisa Hasil Sum of Squares


Within cluster sum of squares by cluster:

*[1] 316.73367  58.21123 174.85164 171.67372 108.49735* 

*(between_SS / total_SS =  92.4 %)*

onsep sum of squares (SS) adalah jumlah “jarak kuadrat” perbedaan tiap titik data dengan mean atau centroidnya. SS ini bisa dengan mean atau centroid untuk tiap cluster atau secara keseluruhan data. Sum of squares dalam literatur data science lain sering disebut dengan Sum of Squared Errors (SSE).

Semakin besar nilai SS menyatakan semakin lebarnya perbedaan antar tiap titik data di dalam cluster tersebut.

Berdasarkan konsep tersebut, berikut adalah penjelasan untuk hasil output kmeans di atas:

1. Nilai 316.73367 adalah SS untuk cluster ke-1, 58.21123 adalah SS untuk cluste ke-2, dan seterusnya. Semakin kecil nilainya berpotensi semakin baik.
2. total_SS: adalah SS untuk seluruh titik terhadap nilai rata-rata global, bukan untuk per cluster. Nilai ini selalu tetap dan tidak terpengaruh dengan jumlah cluster.
3. between_SS: adalah total_SS dikurangi dengan jumlah nilai SS seluruh cluster.
4. (between_SS / total_SS) adalah rasio antara between_SS dibagi dengan total_SS. Semakin besar persentasenya, ummnya semakin baik.

```{r}
#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
#Membandingkan dengan 2 cluster kmeans, masing-masing 2 dan 5
set.seed(1)
kmeans(x=pelanggan[field_yang_digunakan], centers=2, nstart=25)
set.seed(1)
kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)

```
Terlihat untuk 2 cluster (k=2), SS per cluster lebih besar dibandingkan jika data dibagi menjadi 5 cluster (k=5). Perhatikan juga persentase rasio antara between_SS dan total_SS, dimana k=5 juga lebih besar.


Available Components

Analisa terakhir kita dari code adalah bagian kelimat, yaitu sembilan komponen objek yang bisa kita gunakan untuk lihat detil dari objek k-means.

--Lihat Gambar SC--


```{r}
#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
#Bagian K-Means
set.seed(1)
segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)
segmentasi$withinss
segmentasi$cluster
segmentasi$tot.withinss

```
Kesimpulan

Pada bab ini Anda telah menyelesaikan penggunaan algoritma K-Means dengan function kmeans dari dataset yang telah dipersiapkan pada bab kedua.

Function kmeans sederhana digunakan tapi outputnya memiliki informasi yang kaya yaitu:

1. Ukuran / jumlah titik data pada tiap cluster
2. Nilai rata-rata (centroid) dari tiap cluster
3. Vector item dari cluster
4. Jumlah jarak kuadrat dari tiap titik ke centroidnya (Sum of Squares atau SS)
5. Komponen-komponen informasi lain

Dengan menganalisa hasil output ini, kita mampu menggabungkan nomor cluster ke data asal. Selain itu kita juga mengetahui bagaimana kedekatan tiap titik data dari clusternya sehingga menjadi bekal kita untuk menentukan jumlah cluster yang optimal.


MENETUKAN CLUSTER TERBAIK

Dari informasi yang dihasilkan oleh function kmeans, metrick Sum of Squares (SS) atau sering disebut Sum of Squared Errors (SSE) sangat penting untuk dijadikan dasar kita menentukan jumlah cluster yang paling optimal.

Pengantar

Dari informasi yang dihasilkan oleh function kmeans, metrick Sum of Squares (SS) atau sering disebut Sum of Squared Errors (SSE) sangat penting untuk dijadikan dasar kita menentukan jumlah cluster yang paling optimal.

Secara teoritis, berikut adalah beberapa hal yang bisa kita amati dengan SS:

1. Semakin sedikit jumlah cluster yang dihasilkan maka semakin besar nilai SS.
2. Begitu juga sebaliknya, semakin banyak jumlah cluster yang dihasilkan maka semakin kecil nilai SS nya.
3. Karena sifatnya kuadratik, jika terdapat perbedaan yang cukup signifikan antara tiap kombinasi cluster maka perbedaan nilai SS akan semakin besar.
4. Dan seiring bertambahnya jumlah cluster, perbedaan tiap SS ini akan semakin kecil

---Lihat Gambar Cluster---

cluster, dan seterusnya.Perhatikan semakin ke kanan perbedaan jarak antar tiap titik semakin mengecil.

Grafik garis ini memiliki bentuk seperti siku tangan, dan untuk optimal jumlah cluster biasanya kita mengambil titik sikunya. Pada contoh di atas kita bisa mengambil 4 atau 5.

Proses pengambilan keputusan berdasarkan plotting siku ini biasa kita sebut Elbow Effect atau Elbow Method.


YT : https://www.youtube.com/watch?v=PcJXn1fIgJc

Simulasi Jumlah Cluster dan SS

Metrik elbow method yang digunakan sebagai basis justifikasi adalah Sum of Squares (SS), atau lebih tepatnya komponen tot.withinss dari objek kmeans.

Metrik ini akan dicari progressive nilai tot.withinss untuk tiap kombinasi jumlah cluster, dan disimpan dalam bentuk vector di R.

Untuk keperluan ini, kita akan gunakan sapply. Function sapply akan digunakan untuk memanggil function kmeans untuk suatu range jumlah cluster. Range ini akan kita gunakan 1 sampai dengan 10.


```{r}
#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])
pelanggan$NilaiBelanjaSetahun <-pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
#Bagian K-Means
set.seed(1)
sse <- sapply(1:10, function(param_k) {kmeans(pelanggan[field_yang_digunakan], param_k, nstart=25)$tot.withinss})

```
sse :  	Nama variable yang akan digunakan untuk menyimpan nilai tot.withinss dari tiap objek kmeans

sapply : Merupakan function yang digunakan untuk menghasilkan vector dari iterasi (looping) dari eksekusi fungsi tertentu (pada kasus ini: kmeans) dengan nilai range yang diberikan

1:10 : Range jumlah cluster dari 1 sampai dengan 10

param_k : Parameter yang akan berisi nilai 1 sampai dengan 10, sesuai range di atas

kmeans(pelanggan[field_yang_digunakan], param_k, nstart=25) : Fungsi kmeans yang dipanggil sebanyak nilai range 1 sampai dengan 10 (param_k) dari dataset pelanggan

$tot.withinss :  	Total penjumlahan dari tiap SS dari withinss


Grafik Elbow Effect

Kali ini kita akan visualisasikan vector Sum of Squares (SS) atau Sum of Squared Errors (SSE) yang telah kita hasilkan pada praktek sebelumnya.

```{r}
library(ggplot2)

#Bagian Data Preparation
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Profesi <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])
pelanggan$NilaiBelanjaSetahun <- pelanggan$NilaiBelanjaSetahun/1000000
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
#Bagian K-Means
set.seed(1)
sse <- sapply(1:10, function(param_k){kmeans(pelanggan[field_yang_digunakan], param_k, nstart=25)$tot.withinss})

library(ggplot2)

jumlah_cluster_max <- 10
ssdata = data.frame(cluster=c(1:jumlah_cluster_max),sse)
ggplot(ssdata, aes(x=cluster,y=sse)) +
                geom_line(color="red") + geom_point() +
                ylab("Within Cluster Sum of Squares") + xlab("Jumlah Cluster") +
                geom_text(aes(label=format(round(sse, 2), nsmall = 2)),hjust=-0.2, vjust=-0.5) +
  scale_x_discrete(limits=c(1:jumlah_cluster_max))

```

Kesimpulan

Dengan memanfaatkan nilai Sum of Squares (SS) atau Sum of Squared Errors (SSE) kita bisa mengambil keputusan jumlah segmentasi optimal yang kita gunakan.

Ini dilakukan dengan membuat simulasi iterasi jumlah cluster dari 1 sampai dengan jumlah maksimum yang kita inginkan. Pada contoh di bab ini, kita gunakan angka iterasi 1 sampai dengan 10.

Setelah mendapatkan nilai SS dari tiap jumlah cluster, kita bisa plotting ke grafik garis dan menggunakan elbow method untuk menentukan jumlah cluster optimal.


“Pemaketan” Model K-Means

Setelah berhasil mempersiapkan data, menggunakan algoritma kmeans, dan akhirnya bisa memutuskan jumlah cluster terbaik.


Pengantar

Setelah berhasil mempersiapkan data, menggunakan algoritma kmeans, dan akhirnya bisa memutuskan jumlah cluster terbaik.

Maka tahapan berikutnya adalah “memaketkan” atau “membungkus” seluruh referensi hasil konversi dan objek kmeans ini supaya bisa digunakan untuk mengolah data baru dan berguna di bisnis.

Untuk ini tahapannya adalah sebagai berikut:

1. Menamakan cluster dengan karakteristik yang lebih mudah dimengerti. Penamaan ini kita simpan dalam variable Segmen.Pelanggan.
2. Menggabungkan variable Segmen. Pelanggan, Profesi, Jenis.Kelamin, Tipe.Residen, dan Segmentasi ke dalam satu objek bertipe list ke dalam variable Identitas.Cluster.
3. Menyimpan objek Identitas.Cluster dalam bentuk file sehingga dapat digunakan kemudian, ini bisa disebut model bagi kita

```{r}
#Lengkapi dengan dua vector bernama cluster dan Nama.Segmen

Segmen.Pelanggan <- data.frame(cluster=c(1,2,3,4,5), Nama.Segmen=c("Gold Young Professional", "Silver Mid Professional", "Diamond Senior Member", "Silver Youth Gals","Diamond Professional"))



```

1. Cluster 1 :  Gold Young Professional: alasannya adalah karena umurnya rata-rata adalah 31 tahun, professional dan pembelanjaan cukup besar.
Cluster 2 : alasannya adalah karena umurnya rata-rata adalah 52 tahun dan pembelanjaan sekitar 6 juta.
Cluster 3 : Gold Young Professional: alasannya adalah karena umurnya rata-rata adalah 61 tahun dan pembelanjaan di atas 8 juta.
Cluster 4 : : alasannya adalah karena umurnya rata-rata adalah 20, wanita semua, profesinya bercampur antar pelajar dan professional serta pembelanjaan sekitar 6 juta.
Cluster 5 : alasannya adalah karena umurnya rata-rata adalah 42 tahun, pembelanjaan paling tinggi dan semuanya professional.

Menggabungkan Referensi 


a. Dataset pelanggan yang telah “diperkaya” dengan tambahan kolom hasil konversi teks menjadi numerik, dan menormalisasikan field NilaiBelanjaSetahun.
b. Objek kmeans dengan k=5, dipilih berdasarkan metodologi menggunakan metrik Sum of Squares (SS).
c. Membuat variable referensi atau pemetaan numerik dan teks asli (kategori) dari kolom Jenis Kelamin, Profesi dan Tipe Residen.
d. Variable data.frame dengan nama pelanggan yang berisi penamaan cluster sesuai analisa karakteristik dari centroid kolom-kolom pelanggan yang digunakan.
e. Vector dari field yang digunakan.

Akan sangat baik jika semuanya digabungkan di satu variable dengan tipe list, dan ini akan jadi model kita yang dapat disimpan ke dalam file dan digunakan ketika diperlukan.


```{r}
#Membaca data csv dan dimasukkan ke variable pelanggan
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
pelanggan$NilaiBelanjaSetahun = pelanggan$NilaiBelanjaSetahun/1000000
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Residen <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])

#Bagian K-Means
set.seed(1)
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)
Segmen.Pelanggan <- data.frame(cluster=c(1,2,3,4,5), Nama.Segmen=c("Silver Youth Gals", "Diamond Senior Member", "Gold Young Professional", "Diamond Professional", "Silver Mid Professional"))

#Menggabungkan seluruh aset ke dalam variable Identitas.Cluster
Identitas.Cluster <- list(Profesi=Profesi, Jenis.Kelamin=Jenis.Kelamin, Tipe.Residen=Tipe.Residen, Segmentasi=segmentasi, Segmen.Pelanggan=Segmen.Pelanggan, field_yang_digunakan=field_yang_digunakan)


Identitas.Cluster
```

Menyimpan Objek dalam Bentuk File

```{r}
#Membaca data csv dan dimasukkan ke variable pelanggan
pelanggan <- read.csv("https://storage.googleapis.com/dqlab-dataset/customer_segments.txt", sep="\t")
pelanggan_matrix <- data.matrix(pelanggan[c("Jenis.Kelamin", "Profesi", "Tipe.Residen")])
pelanggan <- data.frame(pelanggan, pelanggan_matrix)
pelanggan$NilaiBelanjaSetahun = pelanggan$NilaiBelanjaSetahun/1000000
Profesi <- unique(pelanggan[c("Profesi","Profesi.1")])
Jenis.Kelamin <- unique(pelanggan[c("Jenis.Kelamin","Jenis.Kelamin.1")])
Tipe.Residen <- unique(pelanggan[c("Tipe.Residen","Tipe.Residen.1")])

#Bagian K-Means
set.seed(1)
field_yang_digunakan = c("Jenis.Kelamin.1", "Umur", "Profesi.1", "Tipe.Residen.1","NilaiBelanjaSetahun")
segmentasi <- kmeans(x=pelanggan[field_yang_digunakan], centers=5, nstart=25)
Segmen.Pelanggan <- data.frame(cluster=c(1,2,3,4,5), Nama.Segmen=c("Silver Youth Gals", "Diamond Senior Member", "Gold Young Professional", "Diamond Professional", "Silver Mid Professional"))

Identitas.Cluster <- list(Profesi=Profesi, Jenis.Kelamin=Jenis.Kelamin, Tipe.Residen=Tipe.Residen, Segmentasi=segmentasi, Segmen.Pelanggan=Segmen.Pelanggan, field_yang_digunakan=field_yang_digunakan)

saveRDS(Identitas.Cluster,"cluster.rds")

```

Kesimpulan

Pada penutup bab ini, Anda sudah menggabungkan seluruh aset yang diperlukan untuk membentuk suatu model.

Model ini adalah objek yang bisa digunakan untuk mengolah data baru dan terdiri dari objek kmeans, variable referensi hasil konversi teks ke numerik, dan juga penamaan cluster.

-------------------------------------------------

**Mengoperasionalkan Model K-Means**

Pengantar

Apa yang dimaksud dengan mengoperasionalkan seperti judul pada bab ini?

Ini artinya objek hasil pengolahan algoritma K-Means dan variable-variable terkait yang kita hasilkan sebelumnya harus dapat digunakan ke kasus riil sehingga satu siklus lengkap terjadi.

Kasus riil untuk clustering kita adalah cukup sederhana: bagaimana data baru dapat otomatis membantu tim marketing dan CRM untuk mengidentifikasi segmen mana pelanggan tersebut berada dengan cepat.
Dengan kecepatan identifikasi, maka organisasi atau bisnis dapat dengan cepat bergerak dengan pesan marketing yang efektif dan memenangkan persaingan.


*Data Baru**

Pada teks sebelumnya, disebutkan data pelanggan baru harus cepat dipetakan ke segmen.

Dengan asumsi tiap data pelanggan baru diinput ke dalam sistem, maka pengolahan adalah per record. Pada praktek kali ini, kita akan membuat data.frame dengan satu data dimana nama-nama kolomnya persis dengan dataset awal.

```{r}
databaru <- data.frame(Customer_ID="CUST-100", Nama.Pelanggan="Rudi Wilamar",Umur=20,Jenis.Kelamin="Wanita",Profesi="Pelajar",Tipe.Residen="Cluster",NilaiBelanjaSetahun=3.5)
databaru
```

Memuat Objek Clustering dari File

Praktek kali ini adalah membuka file yang telah kita simpan sebelumnya dengan perintah dan dikenali di R sebagai objek yang akan kita gunakan untuk mengolah data baru.

Untuk membuka file tersebut, kita gunakan function readRDS.

Perintahnya sangat sederhana, berikut adalah contoh untuk membuka file cluster.rds yang telah kita simpan sebelumnya.

```{r}
Identitas.Cluster <- readRDS(file="cluster.rds")
Identitas.Cluster
```

Merge dengan Data Referensi

Dengan adanya data baru dan objek yang berisi data referensi telah dibaca kembali, kita bisa menggabungkan data baru ini untuk mendapatkan konversi numerik dari field Jenis.Kelamin, Profesi dan Tipe.Residen.

Tujuannya adalah kita akan bisa mencari segmen pelanggannya dengan data numerik hasil penggabungan.

Cara menggabungkannya adalah dengan menggunakan function merge, dimana kedua data akan digabungkan dengan mencari persamaan nama kolom dan isinya.

```{r}
databaru <- data.frame(Customer_ID="CUST-100", Nama.Pelanggan="Rudi Wilamar",Jenis.Kelamin="Wanita",Profesi="Pelajar",Tipe.Residen="Cluster",NilaiBelanjaSetahun=3.5)
Identitas.Cluster <- readRDS(file="cluster.rds")
#Masukkan perintah untuk penggabungan data
databaru <- merge(databaru, Identitas.Cluster$Profesi)
databaru <- merge(databaru, Identitas.Cluster$Jenis.Kelamin)
databaru <- merge(databaru, Identitas.Cluster$Tipe.Residen)
databaru
```

a. Variable databaru dengan Identitas.Cluster$Profesi memiliki nama kolom yang sama, yaitu Profesi.
b. Kolom Profesi kemudian akan dijadikan “kunci” untuk menggabungkan kedua variable ini.
c. Ternyata isi Profesi dari databaru, yaitu “Pelajar” juga terdapat di Identitas.Cluster. Ini akan membuat penggabungan menjadi berhasil.
d. Penggabungan ini juga akan mengambil kolom Profesi.1 dan isi data yang terkait dengan Pelajar, yaitu nilai 3.



Menentukan Cluster


Kini saatnya penentuan untuk melakukan praktek terpenting bagi bisnis: data baru ini masuk ke segmen mana?

Tahap :

1. mencari jarak kuadrat minimum atau terdekat
2. dari kolom numerik data baru tersebut
3. ke centroid kolom terkait
4. dari seluruh cluster yang ada

Kalau kita terjemahkan jadi rumus sebagai berikut:

*which.min(sapply( 1:5, function( x ) sum( ( data[kolom] - objekkmeans$centers[x,])^2 ) ))*

dimana:

a. min: merupakan function untuk mencari nilai minimum
b. 1:5 : adalah range nomor cluster dari 1 sampai dengan 5 (atau lebih sesuai dengan ukuran cluster)
c. sapply: digunakan untuk melakukan iterasi berdasarkan range (dalam kasus ini 1 s/d 5)
d. function(x): digunakan untuk proses dengan x diisi 1 s/d 5 per proses
e. (data[kolom] – objekkmeans$centers[x,]) ^2: adalah jarak kuadrat data. Ingat centers adalah komponen dari objek kmeans.
f. sum: digunakan untuk menjumlahkan jarak kuadrat


```{r}
#membuat data baru
databaru <- data.frame(Customer_ID="CUST-100", Nama.Pelanggan="Rudi Wilamar",Umur=32,Jenis.Kelamin="Wanita",Profesi="Pelajar",Tipe.Residen="Cluster",NilaiBelanjaSetahun=3.5)

Identitas.Cluster <- readRDS(file="cluster.rds")

databaru <- merge(databaru, Identitas.Cluster$Profesi)
databaru <- merge(databaru, Identitas.Cluster$Jenis.Kelamin)
databaru <- merge(databaru, Identitas.Cluster$Tipe.Residen)

#menentukan data baru di cluster mana
which.min(sapply( 1:5, function( x ) sum( ( databaru[Identitas.Cluster$field_yang_digunakan] - Identitas.Cluster$Segmentasi$centers[x,])^2 ) ))
Identitas.Cluster$Segmen.Pelanggan[which.min(sapply( 1:5, function( x ) sum( ( databaru[Identitas.Cluster$field_yang_digunakan] - Identitas.Cluster$Segmentasi$centers[x,])^2 ) )),]
```
Kesimpulan

Praktek terakhir menunjukkan bagaimana data pelanggan baru dianalisa oleh model kita dan mengeluarkan nomor cluster atau segmen.

Dengan berakhirnya praktek ini, berarti menunjukkan kita sudah menjalani siklus tahap demi tahap memodelkan dan menggunakan customer segmentation terhadap data kita.

Tahap :


Dimulai dari persiapan data, menggunakan algoritma dan menganalisa hasilnya, mencari jumlah segmentasi paling optimal, memaketkan model yang dihasilkan agar dapat digunakan dalam operasional untuk membantu tim marketing melakukan otomatisasi dan menyampaikan pesan ke target yang tepat.


Perlu diingat bahwa K-Means bukan satu-satunya algoritma clustering, masih banyak algoritma lain seperti Hierarchical Clustering, Parallelized Hierarchical Clustering, dan lain-lain.

Dan setiap algoritma juga memiliki kekurangan dan kelebihan masing-masing. Namun pengetahuan dasar dengan berangkat dari satu algoritma yang populer dan menuntaskannya pastinya akan menjadi bekal berharga.

Untuk selanjutnya, kita akan memperdalam topik penggunaan algoritma clustering ini dalam bentuk latihan dengan project online. Dan tentunya pada saat project ini, dataset yang diberikan juga akan jauh lebih kompleks dan besar.